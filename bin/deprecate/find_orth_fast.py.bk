#! /usr/bin/env python
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#  Copyright Â© xh
# CreateTime: 2016-06-03 13:55:13

# this is new fast and memory efficient version of orthomcl algorithm
import sys
import networkx as nx
from math import log10
import os
from commands import getoutput
from mmap import mmap, ACCESS_WRITE, ACCESS_READ
from collections import Counter
from bisect import bisect_left

# print the manual
def manual_print():
    print 'Usage:'
    print '    python fast_search.py -i foo.sc [-c .5] [-y 50] [-n no]'
    print 'Parameters:'
    print '  -i: tab-delimited file which contain 14 columns'
    print '  -c: min coverage of sequence [0~1]'
    print '  -y: identity [0~100]'
    print '  -n: normalization score [no|bsr|bal]. bsr: bit sore ratio; bal:  bit score over anchored length. Default: no'
    print '  -a: cpu number for sorting. Default: 1'
    print '  -t: keep tmpdir[y|n]. Default: n'


argv = sys.argv
# recommand parameter:
args = {'-i':'', '-c':.5, '-y':50, '-n':'no', '-t':'n', '-a':'4'}

N = len(argv)
for i in xrange(1, N):
    k = argv[i]
    if k in args:
        try:
            v = argv[i+1]
        except:
            break
        args[k] = v
    elif k[:2] in args and len(k) > 2:
        args[k[:2]] = k[2:]
    else:
        continue

if args['-i']=='':

    manual_print()
    raise SystemExit()

try:
    qry, coverage, identity, norm, tmpdir, np = args['-i'], float(args['-c']), float(args['-y']), args['-n'], args['-t'], int(args['-a'])

except:
    manual_print()
    raise SystemExit()


# the ortholog class
class OTH:
    def __init__(self, fn=None, cov=.95, idy=0, evl=1e-5, norm='bal'):
        self.fn = fn
        self.cov = cov
        self.idy = idy
        self.evl = evl
        self.norm = norm

    # get the basic information like length of each sequence
    # convert locus name to number
    def basic(self):
        assert self.fn
        self.loc = []
        self.lns = []
        self.mxb = []
        #self.N = 0
        # get length of each sequence
        flag = None
        f = open(self.fn, 'r')
        for i in f:
            j = i[:-1].split('\t')
            qid = j[0]
            if flag != qid:
                qln = max(map(float, j[6:8]))
                sco = float(j[11])
                self.loc.append(qid)
                self.lns.append(qln)
                self.mxb.append(sco)
                flag = qid
            else:
                continue


        self.N = len(self.loc)
        f.close()

        # map loc to idx
        self.l2i = {}
        for i in xrange(self.N):
            loc = self.loc[i]
            self.l2i[loc] = i

    # get loc by index
    def idx2loc(self, idx):
        return self.loc[idx]

    # get index by loc
    def loc2idx(self, qid):
        return self.l2i.get(qid)

    # get max bit score of query
    def get_mxb(self, qid):
        i = self.loc2idx(qid)
        if i:
            return self.mxb[i]
        else:
            return -1

    # get the length of query sequence
    def get_lns(self, qid):
        i = self.loc2idx(qid)
        if i:
            return self.lns[i]
        else:
            return -1

    # parse blast8
    def parse(self, f):
        flag = None
        hits = {}
        for i in f:
            j = i[:-1].split('\t')
            qid, sid = j[:2]
            idy, aln, mis, gop, qst, qed, sst, sed, evl, sco = map(float, j[2:12])
            qln, sln = map(self.get_lns, [qid, sid])
            qcv = (abs(qed-qst)+1.)/qln
            scv = (abs(sed-sst)+1.)/sln
            if min(qcv, scv) < self.cov or idy < self.idy or evl > self.evl:
                continue

            if self.norm == 'bsr':
                mxb = self.get_mxb(qid)
                sco /= mxb
            elif self.norm == 'bsl':
                sco /= aln
            else:
                pass

            if qid not in hits:
                outs = hits.values()
                if outs:
                    yield outs[0]

                hits = {qid: [[qid, sid, sco]]}
            else:
                hits[qid].append([qid, sid, sco])

        outs = hits.values()
        if outs:
            yield outs[0]

    # get Q_inparalog and Q_(co-)ortholog
    def get_qico(self, hits):
        flag = 0
        ips, ots, cos = [], {}, []
        for hit in hits:
            qid, sid, sco = hit
            qtx = qid.split('|')[0]
            stx = sid.split('|')[0]
            if qtx == stx:
                if flag == 0:
                    ips.append(hit)
                else:
                    cos.append(hit)
            else:
                flag = 1
                if stx not in ots:
                    ots[stx] = hit
                else:
                    cos.append(hit)

        ots = ots.values()
        return ips, ots, cos


    # get the range of a given qid
    def get_range(self, loc, qids):
        i = self.loc2idx(loc)
        if i:
            start, end = qids[i:i+2]
        else:
            start = end = -1
        return start, end

    # given qid and sid, return index
    def get_pair(self, qid, qids, sid, sids):
        x, y = map(self.loc2idx, [qid, sid])
        x, y = x <= y and [x, y] or [y, x]
        start, end = qids[x:x+2]
        if start == end or not sids:
            return -1
        else:
            Y = bisect_left(sids, y, start, end-1)
            return y == sids[Y] and Y or -1



    # add hits into qids, sids and scos
    def add_hits(self, qids, sids, scos, hits):
        #[[self.loc2idx(elem[0]), self.loc2idx(elem[1]), elem[2]] for elem in hits]
        new = []
        for qid,sid,sco in hits:
            x, y = map(self.loc2idx, [qid, sid])
            #if qids == self.qip_qids:
            #    print 'paralogs', 'qid', qid, x, 'sid', sid, y, self.loc, sids
            if x < y:
                new.append([y, -sco])

            elif x > y:
                z = self.get_pair(qid, qids, sid, sids)
                if z != -1:
                    scos[z] = (sco - scos[z])/2.
            else:
                continue

        new.sort()
        sids.append([elem[0] for elem in new])
        scos.append([elem[1] for elem in new])
        qids.append(len(sids))


    # identify (co-)orthologs and paralogs
    def fit(self, fn=None):
        if fn != None:
            self.fn = fn
        self.basic()
        # filter by coverage and idy
        flag = None
        self.qip_qids = [0]
        self.qip_sids = []
        self.qip_scos = []
        self.qot_qids = [0]
        self.qot_sids = []
        self.qot_scos = []
        self.qco_qids = [0]
        self.qco_sids = []
        self.qco_scos = []
        qips = []
        qots = []
        qcos = []
        self.loc = []
        idx = 0
        f = open(self.fn, 'r')
        for hits in self.parse(f):
            qid = hits[0][0]
            print 'hits is', qid, hits
            self.loc.append(qid)
            self.l2i[qid] = idx
            idx += 1
            qip_hits, qot_hits, cos_hits = self.get_qico(hits)
            self.add_hits(self.qip_qids, self.qip_sids, self.qip_scos, qip_hits)
            self.add_hits(self.qot_qids, self.qot_sids, self.qot_scos, qot_hits)
            self.add_hits(self.qco_qids, self.qco_sids, self.qco_scos, cos_hits)

        f.close()

        self.N = len(self.loc)
        #self.l2i = {}
        #for i in xrange(self.N):
        #    self.l2i[self.loc[i]] = i
 

    # get orthologs
    def get_ots(self):
        for qid in self.loc:
            start, end = self.get_range(qid, self.qot_qids)
            for i in xrange(start, end):
                sco = self.qot_scos[i]
                if sco >= 0:
                    sid = self.loc[self.qot_sids[i]]
                    yield qid, sid, sco

    # get paralogs
    def get_ips(self):
        for qid in self.loc:
            start, end = self.get_range(qid, self.qip_qids)
            for i in xrange(start, end):
                sco = self.qip_scos[i]
                if sco >= 0:
                    sid = self.loc[self.qip_sids[i]]
                    yield qid, sid, sco
               

    # get co by given a ortholog
    def get_co(self, qid, sid):
        # get ips
        qst, qed = self.get_range(qid, self.qip_qids)
        qips = [qid]
        qips.extend([self.loc[self.qip_sids[elem]] for elem in xrange(qst, qed)])

        sst, sed = self.get_range(sid, self.qip_qids)
        sips = [sid]
        sips.extend([self.loc[self.qip_sids[elem]] for elem in xrange(sst, sed)])
        for qip in qips:
            for sip in sips:
                i = self.get_pair(qip, self.qot_qids, sip, self.qot_sids)
                j = self.get_pair(qip, self.qco_qids, sip, self.qco_sids)
                if i == -1 and j != -1:
                    sco = self.qco_scos[j]
                    yield qip, sip, sco
                else:
                    continue



clf = OTH(qry)
clf.fit()
for i in clf.get_ips():
    print i

